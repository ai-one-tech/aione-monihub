## 问题复盘
- 报错：`index.tsx:344 ReferenceError: setSelectedTaskType is not defined`，原因是新增调用了 `setSelectedTaskType(taskType)`，但未定义对应的 `useState`。
- 自动刷新无效：`task-instances` 的 `refetchInterval` 绑定了 `hasActive`，在首次数据未进入进行中状态时不轮询，导致无法检测到后续状态变化。
- 需求回顾：
  1. 开关开启时滑块在右侧（已满足，`checked={autoRefreshEnabled}`）。
  2. 仅刷新“相关实例”和“执行结果”，任务列表不再自动刷新（已将任务列表轮询关闭）。
  3. 当相关实例没有需要刷新的数据（无进行中）时，自动停止刷新、关闭并禁用开关。

## 修改方案
1. 定义缺失的任务类型状态：在 `selectedTask` 旁新增
   - `const [selectedTaskType, setSelectedTaskType] = useState<string | null>(null)`。
2. 任务选择时同步类型：在 `handleTaskSelect(taskId)` 中
   - 通过 `tasksData?.data?.find(t => t.id === taskId)` 取类型并 `setSelectedTaskType(t?.task_type || null)`。
3. 发起任务后同步类型：在创建任务成功后 `setTimeout` 中
   - 在 `setSelectedTask(newTask.id)` 之后调用 `setSelectedTaskType(taskType)`，避免依赖任务列表刷新。
4. 统一自动刷新策略到“仅由开关决定”：
   - 将 `task-instances` 的 `refetchInterval` 改为 `() => (autoRefreshEnabled ? refreshIntervalMs : false)`，不依赖 `hasActive`，保证创建新任务后即开始轮询以捕获状态变更。
5. 自动停止逻辑（副作用）：
   - 当有选中任务但 `hasActiveInstances` 为 `false` 且开关为开时，自动 `setAutoRefreshEnabled(false)`；`autoRefreshNotNeeded = !selectedTask || !hasActiveInstances` 用于禁用开关与间隔选择。
6. 任务结果区使用 `selectedTaskType` 进行输出格式判断（shell/code），保持已有变更一致。

## 验证步骤
- 发起新任务后：确认不刷新任务列表，仅选中新任务；自动刷新立即开始对“相关实例”和“执行结果”轮询。
- 当实例全部非进行中：观察自动停止轮询、开关关闭并禁用（间隔选择亦禁用）。
- 切换任务：`selectedTaskType` 正确更新，结果区输出格式（如 shell 的 `output`）正常。

## 注意事项
- 不修改任务历史的自动刷新；保留手动刷新按钮行为。
- 若需要避免“瞬时无进行中导致提前停更”，可按需增加“连续 N 次无进行中才关闭”的稳定性阈值，当前方案按一次判定即可停止。