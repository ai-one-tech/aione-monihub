# 开发指南

<cite>
**本文档中引用的文件**  
- [cz.yaml](file://apps/frontend/cz.yaml)
- [eslint.config.js](file://apps/frontend/eslint.config.js)
- [tsconfig.json](file://apps/frontend/tsconfig.json)
- [tsconfig.app.json](file://apps/frontend/tsconfig.app.json)
- [tsconfig.node.json](file://apps/frontend/tsconfig.node.json)
- [package.json](file://apps/frontend/package.json)
- [Cargo.toml](file://apps/server/Cargo.toml)
</cite>

## 目录
1. [代码提交规范](#代码提交规范)
2. [分支管理策略](#分支管理策略)
3. [代码质量配置](#代码质量配置)
4. [测试执行指南](#测试执行指南)
5. [文档生成说明](#文档生成说明)
6. [调试技巧](#调试技巧)
7. [代码质量要求](#代码质量要求)

## 代码提交规范

本项目采用 Conventional Commits 规范进行 Git 提交消息管理，确保提交历史清晰、可追溯。通过 `cz.yaml` 配置文件集成 Commitizen 工具，自动化生成符合规范的提交信息。

Conventional Commits 格式如下：
```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```

支持的提交类型包括：`feat`（新功能）、`fix`（修复）、`docs`（文档）、`style`（格式）、`refactor`（重构）、`test`（测试）、`chore`（构建）等。

版本号遵循语义化版本控制（SemVer），标签格式为 `v$version`，并在版本升级时自动更新变更日志。

**Section sources**
- [cz.yaml](file://apps/frontend/cz.yaml#L1-L8)

## 分支管理策略

本项目采用 **Trunk-Based Development**（主干开发）策略，强调持续集成与快速交付。所有开发人员基于 `main` 分支创建短期功能分支（feature branches），通常生命周期不超过一天。

### 主要分支：
- `main`：主干分支，始终可部署，受保护，禁止直接推送
- `release/*`：发布分支，用于准备版本发布
- `hotfix/*`：紧急修复分支，直接从 `main` 派生

### 工作流程：
1. 从 `main` 拉取最新代码
2. 创建功能分支：`git checkout -b feature/your-feature`
3. 完成功能开发并运行本地测试
4. 提交更改（使用 `git cz` 命令确保格式正确）
5. 推送分支并创建 Pull Request
6. 经代码审查后合并至 `main`

所有合并必须通过 CI/CD 流水线验证，包括代码检查、单元测试和构建。

## 代码质量配置

### ESLint 配置
前端项目使用 `eslint.config.js` 进行代码静态检查，集成 TypeScript、React 和 TanStack Query 的最佳实践。

关键规则包括：
- 禁止使用 `console` 输出
- 启用 TypeScript 的 `no-unused-vars` 检查，忽略以 `_` 开头的变量
- 强制使用类型导入（`import type`）以优化打包
- 禁止重复导入同一模块

配置忽略 `dist` 构建目录和 UI 组件库代码。

**Section sources**
- [eslint.config.js](file://apps/frontend/eslint.config.js#L1-L59)

### TypeScript 配置
TypeScript 配置采用多文件引用模式，主配置 `tsconfig.json` 引用两个子配置：

- `tsconfig.app.json`：应用源码配置，目标 ES2020，启用严格类型检查
- `tsconfig.node.json`：Node.js 环境配置，用于 Vite 构建脚本

启用路径别名 `@/*` 指向 `src/*`，提升模块导入可读性。所有配置均启用 `strict` 模式，确保类型安全。

**Section sources**
- [tsconfig.json](file://apps/frontend/tsconfig.json#L1-L14)
- [tsconfig.app.json](file://apps/frontend/tsconfig.app.json#L1-L33)
- [tsconfig.node.json](file://apps/frontend/tsconfig.node.json#L1-L25)

### Rust 格式化
后端 Rust 服务通过 `rustfmt` 统一代码风格。开发者应在提交前运行 `cargo fmt` 格式化代码。

Rust 项目配置位于 `Cargo.toml`，定义了依赖项、构建目标和工作区设置。CI 流水线将验证代码格式是否符合标准。

**Section sources**
- [Cargo.toml](file://apps/server/Cargo.toml#L1-L20)

## 测试执行指南

### 前端测试
前端项目在 `package.json` 中定义了测试脚本，使用 Vitest 作为测试框架。

常用命令：
- `npm test`：运行所有单元测试
- `npm run test:watch`：监听模式运行测试
- `npm run test:coverage`：生成代码覆盖率报告

测试文件位于 `src/**/*.test.tsx`，遵循 React Testing Library 最佳实践。

### 后端测试
Rust 服务在 `Cargo.toml` 中配置测试依赖，使用标准 `cargo test` 命令运行单元测试和集成测试。

测试组织方式：
- 单元测试：内联于模块中，使用 `#[cfg(test)]`
- 集成测试：位于 `tests/` 目录下，测试跨模块交互
- 端到端测试：模拟 HTTP 请求验证 API 行为

CI 流水线将自动执行 `cargo test --workspace` 运行所有包的测试。

**Section sources**
- [package.json](file://apps/frontend/package.json#L1-L20)
- [Cargo.toml](file://apps/server/Cargo.toml#L1-L20)

## 文档生成说明

### API 文档生成
后端 Rust API 使用 **Utoipa** 自动生成 OpenAPI 3.0 规范文档。通过属性宏（`#[utoipa::path]`）注解路由处理函数，提取路径、参数、请求体和响应模型。

文档生成步骤：
1. 在 `main.rs` 中配置 Utoipa 文档提取
2. 使用 `utoipa-swagger-ui` 提供交互式文档界面
3. 运行 `cargo doc` 生成静态文档

API 文档自动包含请求示例、状态码说明和数据模型定义。

### 前端组件文档
前端组件使用 **TSDoc** 注释生成文档。所有公共组件和 Hook 应包含：
- `@description`：功能描述
- `@param`：参数说明
- `@returns`：返回值说明
- `@example`：使用示例

文档工具链基于 VitePress，运行 `npm run docs:build` 生成静态站点。

### 代码覆盖率报告
测试覆盖率通过以下工具生成：
- 前端：Vitest 内置 `--coverage` 选项，输出 lcov 格式报告
- 后端：`cargo tarpaulin` 生成 Rust 代码覆盖率

CI 流水线将上传覆盖率报告至 Codecov 或类似平台，可视化展示覆盖情况。

## 调试技巧

### 前端调试
- 使用 **React DevTools** 检查组件树、状态和性能
- 启用 `StrictMode` 检测潜在问题
- 利用 `console.log` 调试（提交前必须移除）
- 使用 `React Query Devtools` 监控数据请求状态

### 后端调试
- 使用 `env_logger` 记录结构化日志，通过 `RUST_LOG=debug` 控制日志级别
- 在关键路径插入 `tracing` 宏进行分布式追踪
- 使用 `curl` 或 Postman 手动测试 API 端点
- 启用 `pretty-print` 格式化错误输出

开发环境建议设置 `RUST_BACKTRACE=1` 以获取完整调用栈。

## 代码质量要求

### 单元测试覆盖率
- 前端：核心业务逻辑覆盖率 ≥ 85%
- 后端：关键路径覆盖率 ≥ 90%
- 新增代码必须附带测试，禁止无测试的生产代码提交

### PR 审查流程
所有 Pull Request 必须满足：
1. 通过 CI/CD 流水线（构建、测试、检查）
2. 至少一名团队成员批准
3. 提交消息符合 Conventional Commits 规范
4. 代码风格符合 ESLint/rustfmt 要求
5. 包含适当的测试用例

审查重点包括：逻辑正确性、边界条件处理、性能影响和可维护性。

### 自动化 CI/CD 流水线
CI/CD 流水线包含以下阶段：
1. **代码检查**：运行 ESLint、rustfmt、knip（死代码检测）
2. **测试执行**：并行运行前端和后端测试
3. **构建**：打包前端资源，编译 Rust 二进制
4. **部署**：通过 Netlify 部署前端，Docker 部署后端服务

流水线配置在 `netlify.toml` 和 CI 配置文件中定义，确保每次提交都经过完整验证。

**Section sources**
- [netlify.toml](file://apps/frontend/netlify.toml#L1-L10)
- [knip.config.ts](file://apps/frontend/knip.config.ts#L1-L15)